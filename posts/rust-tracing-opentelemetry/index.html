<!doctype html><html lang=en><head><title>Flexible Tracing with Rust and OpenTelemetry OTLP</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exporting traces to Jaeger, Honeycomb and other backends using Rust tracing and OpenTelemetry."><link href="/css/main.min.cbea4dffd5bf7bf2c87de9504c4cac811c1f22ad854c538f0e08bbad25d60973.css" rel=stylesheet><link rel=icon type=image/svg+xml href=/images/logo.svg><link rel=stylesheet href=https://rsms.me/inter/inter.css><script src=/js/prism.js></script></head><body class="bg-stone-50 text-stone-600 dark:bg-stone-900 dark:text-stone-400"><nav class="mb-1 shadow dark:shadow-none dark:border-b dark:border-stone-300/10"><div class="max-w-7xl mx-auto px-2 sm:px-6 lg:px-8"><div class="relative flex justify-between h-20"><div class="absolute inset-y-0 left-0 flex items-center sm:hidden"><button id=menu-button type=button class="inline-flex items-center justify-center p-2 rounded-md text-stone-400 hover:text-stone-500 hover:bg-stone-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-red-600" aria-controls=mobile-menu aria-expanded=false>
<span class=sr-only>Open main menu</span><svg id="open-menu-icon" class="block h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg><svg id="close-menu-icon" class="hidden h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18 18 6M6 6l12 12"/></svg></button></div><div class="flex-1 flex items-center justify-center sm:items-stretch sm:justify-start"><div class="flex-shrink-0 flex items-center"><a href=/><svg class="block lg:hidden h-14 w-auto dark:fill-stone-300 dark:stroke-stone-400" viewBox="0 0 1250 1250"><desc>Broch logo</desc><path d="M50 550A5e2 5e2.0 01550 50h145a5e2 5e2.0 015e2 5e2v1e2a5e2 5e2.0 01-5e2 5e2v-130a370 370 0 00370-370m0-1e2A370 370 0 00695 180H550A370 370 0 00180 550m0 1e2a370 370 0 00370 370v130A5e2 5e2.0 0150 650V550" stroke-width="55" fill="none"/></svg><svg class="hidden lg:block h-14 w-auto dark:fill-stone-300 dark:stroke-stone-400" stroke="#292524" fill="#292524" viewBox="0 0 3500 1250"><desc>Broch logo</desc><g><path d="M50 550A5e2 5e2.0 01550 50h145a5e2 5e2.0 015e2 5e2v1e2a5e2 5e2.0 01-5e2 5e2v-130a370 370 0 00370-370m0-1e2A370 370 0 00695 180H550A370 370 0 00180 550m0 1e2a370 370 0 00370 370v130A5e2 5e2.0 0150 650V550" stroke-width="55" fill="none"/></g><g transform="translate(1600 1050) scale(.18 -.18)"><path d="m525 3939c-137-15-256-28-263-28-10-1-12-289-10-1423l3-1423 267-3 267-2 5 32c3 18 10 60 16 92 5 33 10 62 10 64 0 3 33-26 73-64 85-82 137-114 243-151 71-24 93-27 214-27 98-1 153 4 2e2 17 258 69 463 295 555 613 40 137 55 260 55 456 0 417-89 7e2-279 888-128 127-269 181-471 182-201 0-342-54-472-183l-78-76v533 534l-42-1c-24-1-155-14-293-30zm811-1247c56-29 119-103 144-169 34-92 51-230 51-427 0-99-5-213-11-251-31-198-95-316-204-373-44-22-63-26-136-26-122 0-203 40-281 137l-39 50v427 428l43 59c63 84 130 136 217 164 46 15 171 4 216-19z"/><path d="m8303 3942-253-25V2493 1070h3e2 3e2v698 697l51 67c96 128 197 192 303 192 70-1 115-20 144-61 47-69 46-54 50-845l3-748h299 3e2v803c0 891 0 881-66 1016-108 219-359 323-642 265-141-29-251-87-366-195l-76-71v541 541l-47-1c-27-1-162-13-3e2-27z"/><path d="m4655 3155c-268-42-482-178-629-399-234-353-231-1006 7-1356 123-181 310-311 521-360 182-44 421-44 591 0 1e2 25 241 93 322 154 302 228 436 668 356 1166-60 379-286 657-618 759-155 48-380 63-550 36zm306-445c82-23 161-105 2e2-209 65-175 77-537 23-744-35-138-99-228-192-274-50-24-68-28-147-28-105 0-163 23-226 88-99 102-148 320-136 612 7 171 27 277 72 372 78 167 225 234 406 183z"/><path d="m6898 3155c-402-68-686-357-779-795-29-136-32-406-6-547 87-473 408-765 884-803 134-10 285 3 399 35 156 44 393 176 380 211-4 10-223 326-250 361-1 1-51-22-111-52-79-39-135-59-198-71-81-16-93-16-169-1-236 46-330 240-315 642 9 231 49 363 140 462 136 147 391 144 613-7l40-28 128 175c72 1e2 125 182 122 190-9 23-187 132-269 164-195 75-410 97-609 64z"/><path d="m3498 3137c-153-53-279-181-354-364-13-32-24-53-24-48-1 6-11 91-23 190l-22 180-267 3-268 2V2085 1070h305 304l3 533 3 532 33 95c98 283 233 378 480 337 60-10 85-11 88-3 7 20 94 569 91 573-10 10-121 23-196 23-63 0-104-7-153-23z"/></g></svg></a></div><div class="hidden sm:ml-9 sm:flex sm:space-x-8"><a class="border-transparent text-stone-400 hover:border-stone-300 hover:text-stone-700 dark:hover:text-stone-400 inline-flex items-center px-1 pt-1 border-b-2 text-lg font-medium" href=/ title>Home</a>
<a class="border-red-600 dark:border-red-500 text-stone-900 dark:text-stone-300 inline-flex items-center px-1 pt-1 border-b-2 text-lg font-medium" href=/posts/ title=Blog>Blog</a></div></div><div class="absolute inset-y-0 right-0 flex items-center pr-2 sm:static sm:inset-auto sm:ml-6 sm:pr-0"><a href=/index.xml class="p-1 rounded-full text-stone-400 hover:text-stone-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"><span class=sr-only>RSS Feed</span><svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 5c7.18.0 13 5.82 13 13M6 11a7 7 0 017 7m-6 0a1 1 0 11-2 0 1 1 0 012 0z"/></svg></a></div></div></div><div class=hidden id=mobile-menu><div class="pt-2 pb-4 space-y-1"><a class="border-transparent text-stone-500 dark:text-stone-300 hover:bg-stone-50 dark:hover:bg-stone-400 hover:border-stone-300 hover:text-stone-700 block pl-3 pr-4 py-2 border-l-4 text-base font-medium" href=/ title>Home</a>
<a class="bg-red-50 dark:bg-red-800 border-red-600 text-red-900 dark:text-red-300 block pl-3 pr-4 py-2 border-l-4 text-base font-medium" href=/posts/ title=Blog>Blog</a></div></div></nav><script>var menu_open=!1,menu_button=document.getElementById("menu-button"),menu=document.getElementById("mobile-menu"),open_icon=document.getElementById("open-menu-icon"),close_icon=document.getElementById("close-menu-icon");menu_button.addEventListener("click",function(){menu_open=!menu_open,menu_open?(menu.className="block sm:hidden",close_icon.className.baseVal="block h-6 w-6",open_icon.className.baseVal="hidden h-6 w-6"):(menu.className="hidden",open_icon.className.baseVal="block h-6 w-6",close_icon.className.baseVal="hidden h-6 w-6")})</script><div class="w-full max-w-7xl mx-auto"><main><article class="py-12 px-4 sm:px-8 lg:px-8 prose prose-stone prose-lg max-w-none lg:prose-xl dark:prose-invert"><h1>Flexible Tracing with Rust and OpenTelemetry OTLP</h1><p class="block flex display-between text-stone-500 dark:text-stone-400 italic">April 6, 2023
<span class=ml-3>(Updated, January 12, 2024)</span></p><p>If you have been using log files all your life, the telemetry ecosytem can be a bit daunting for a newcomer. And if you&rsquo;ve just discovered Rust&rsquo;s <a href=https://tokio.rs/#tk-lib-tracing>tracing</a> framework, it&rsquo;s not immediately clear where to look beyond the basic examples. There are a lot of crates and APIs to get your head round and a lot of new terminology. This article isn&rsquo;t intended to be a complete tutorial but will explain how to set up a configuration which works with multiple systems and hopefully provide some insight into how things fit together. For an overview of telemetry, the <a href=https://opentelemetry.io/docs/concepts/observability-primer>OpenTelemetry Observability Primer</a> is a quick introduction. Note that tracing can theoretically take place across multiple processes, but we&rsquo;ll only be dealing with exporting data from a single web application here. Source code for a working application can be found <a href=https://github.com/tekul/rust-tracing-otlp>on github</a>.</p><h2 id=the-rust-tracing-and-telemetry-ecosystem>The Rust tracing and telemetry ecosystem</h2><p>Rust has its own <a href=https://crates.io/crates/tracing>tracing framework</a>. Getting started with some logging to <code>stdout</code> is easy. You can just add:</p><pre><code class=language-rust>tracing_subscriber::fmt().init();
</code></pre><p>to your <code>main</code> function. If you are running a web application you can use integrations such as those for <a href=https://docs.rs/tracing-actix-web/latest/tracing_actix_web/>actix</a> or <a href=https://docs.rs/tower-http/latest/tower_http/trace/index.html>axum</a>, add some <a href=https://docs.rs/tracing/0.1.37/tracing/index.html#events-1>tracing events</a> to your code and you will see output in the console <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>But you want more than console output, right? Tracing links the various &ldquo;spans&rdquo; and log events from a single HTTP request together and we want to see them collected in a dashboard so we can track what happened during each request, query the data and so on. At this point you might read about the <a href=https://crates.io/crates/tracing-opentelemetry><code>tracing-opentelemetry</code></a> and <a href=https://crates.io/crates/opentelemetry><code>opentelemetry</code></a> crates. The <code>opentelemetry</code> crate lists yet more crates which you can use to export traces to various backends. One of these is <a href=https://www.jaegertracing.io/>Jaeger</a> which is a popular open source tool, with a nice UI. You can easily run it locally using Docker, it&rsquo;s often used in blog articles and many of the code samples on <code>crates.io</code> use it.</p><p>This is roughly where I was about a year ago. I was working on a system which I&rsquo;d integrated with Rust <code>tracing</code> and copied one of those samples to export to Jaeger using the <a href=https://crates.io/crates/opentelemetry-jaeger><code>opentelemetry-jaeger</code></a> crate. But ideally we wanted to provide a binary to users and allow them to choose their own telemetry backend. OpenTelemetry didn&rsquo;t seem to be providing a lot of value if we had to compile against a different integration crate each time 🤔.</p><p>On revisiting this issue and doing a bit more research, I realised that OpenTelemetry defines <a href=https://opentelemetry.io/docs/reference/specification/protocol/>its own protocol</a>, OTLP (hence the &ldquo;Open&rdquo; 🙄), and that it is <em>directly supported</em> by Jaeger as well as by many <a href=https://opentelemetry.io/ecosystem/vendors/>commercial vendors</a>. In fact, Jaeger has now deprecated its own clients in favour of OTLP, so the <code>opentelemetry-jaeger</code> crate is really redundant.</p><p>This makes things much simpler. Hiding in that big list of OpenTelemetry crates is <a href=https://crates.io/crates/opentelemetry-otlp><code>opentelemetry-otlp</code></a>. If we use that then hopefully our system will &ldquo;just work&rdquo; with these compatible backends.</p><p>Let&rsquo;s see how far we can get.</p><h2 id=required-crates>Required crates</h2><p>For a setup combining Rust tracing and OpenTelemetry/OTLP we need the following crates:</p><ul><li><code>tracing</code> &ndash; to instrument our Rust code.</li><li><code>tracing-subscriber</code> &ndash; allows us to listen for tracing events and define how they are filtered and exported.</li><li><code>opentelemetry</code> &ndash; OpenTelemetry&rsquo;s API-level view of tracing, spans, etc.</li><li><code>opentelemetry_sdk</code> &ndash; Implements the OpenTelemetry APIs <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</li><li><code>tracing-opentelemetry</code> &ndash; provides a compatibility layer between the two.</li><li><code>opentelemetry-otlp</code> &ndash; the protocol implementation to export data to Jaeger or some other backend.</li></ul><p>The <code>tracing-subscriber</code> crate also helpfully processes messages generated by code using the <code>log</code> crate <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, converting them to tracing events. This is useful if you&rsquo;re using a library such as <code>tokio-postgres</code> and want to see the interactions with the database during a request.</p><p>Some of these crates are maintained by the tokio tracing team and some are part of the OpenTelemetry organization. It&rsquo;s important that the versions are compatible or you can get errors as everything is still quite unstable. Some of the code also requires specific crate features to be enabled. The <code>Cargo.toml</code> file from the <a href=https://github.com/tekul/rust-tracing-otlp>example code</a> can be used as a starting point.</p><h2 id=basic-tracing-setup>Basic Tracing Setup</h2><p>Rust tracing allows us to instrument our code to generate spans and events. We then need to define at least one <a href=https://docs.rs/tracing-core/0.1.30/tracing_core/subscriber/trait.Subscriber.html><code>Subscriber</code></a> to capture and log these events somewhere. The code <code>tracing_subscriber::fmt().init();</code> creates a simple subscriber which, by default, writes timestamped output to the console similar to a traditional log.
This is roughly equivalent to <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>:</p><pre><code class=language-rust>use tracing_subscriber::prelude::*;

let fmt_layer = tracing_subscriber::fmt::layer();
tracing_subscriber::registry().with(fmt_layer).init();
</code></pre><p><a href=https://docs.rs/tracing-subscriber/0.3.16/tracing_subscriber/layer/index.html>Layers</a> allow us to use multiple subscribers if we want, and also to add filtering. An easy way to add filtering is to add an <a href=https://docs.rs/tracing-subscriber/0.3.16/tracing_subscriber/struct.EnvFilter.html><code>EnvFilter</code></a> as an extra layer:</p><pre><code class=language-rust>tracing_subscriber::registry()
    .with(fmt_layer)
    .with(tracing_subscriber::EnvFilter::from_default_env())
    .init();
</code></pre><p>This will filter the output based on the value of the environment variable <code>RUST_LOG</code> <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</p><p>Now try running the sample application:</p><pre><code class=language-shell>$ RUST_LOG=&quot;info&quot; cargo run
</code></pre><p>We see some log messages as the server starts up.</p><pre><code>2023-04-03T12:17:04.513692Z  INFO rust_tracing_otlp: Starting server
2023-04-03T12:17:04.515377Z  INFO actix_server::builder: starting 2 workers
</code></pre><p>Now if we request the <code>/rand</code> endpoint which generates and returns a random number:</p><pre><code class=language-shell>$ curl localhost:8080/rand
Hello. Your random number is 7789005614985398892.
</code></pre><p>But we don&rsquo;t see anything in the server log 🤔. Why doesn&rsquo;t our request span appear? This is part of the way the <code>fmt</code> subscriber works. It logs the events in our code (where we have <code>debug</code>, <code>trace</code> etc), but doesn&rsquo;t log spans by default <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>. If we enable debug level logging then we will see output during our request, since we have debug statements in the request handler:</p><pre><code class=language-shell>$ RUST_LOG=&quot;debug,h2=warn&quot; cargo run
...
2023-04-03T12:50:27.485688Z  INFO rust_tracing_otlp: Starting server
2023-04-03T12:50:27.487449Z  INFO actix_server::builder: starting 2 workers
2023-04-03T12:50:27.487473Z  INFO actix_server::server: Tokio runtime found; starting in existing Tokio runtime
2023-04-03T12:50:30.626347Z DEBUG HTTP request{http.method=GET http.route=/rand http.flavor=1.1 http.scheme=http http.host=localhost:8080 http.client_ip=127.0.0.1 http.user_agent=curl/8.0.1 http.target=/rand otel.name=HTTP GET /rand otel.kind=&quot;server&quot; request_id=a862d880-dd54-4a3f-a175-101b1e00b5f9}:get_random: rust_tracing_otlp: Generating random number
2023-04-03T12:50:30.626389Z DEBUG HTTP request{http.method=GET http.route=/rand http.flavor=1.1 http.scheme=http http.host=localhost:8080 http.client_ip=127.0.0.1 http.user_agent=curl/8.0.1 http.target=/rand otel.name=HTTP GET /rand otel.kind=&quot;server&quot; request_id=a862d880-dd54-4a3f-a175-101b1e00b5f9}:get_random: rust_tracing_otlp: Value is 5478471227533226790
</code></pre><p>The additional attributes added by <code>tracing-actix-web</code> are also visible with each log message. This is still unstructured logging though. Events are logged individually and events from different requests may be interleaved.</p><h2 id=adding-opentelemetry-to-the-mix>Adding OpenTelemetry to the mix</h2><p>As a first step towards using OpenTelemetry, we can swap the <code>fmt</code> layer for an <code>opentelemetry</code> <code>stdout</code> &ldquo;tracer&rdquo; (update: this now also requires the <code>opentelemetry_stdout</code> crate). We then use <code>tracing_opentelemetry</code> to convert it to a layer compatible with our previous code:</p><pre><code class=language-rust>use opentelemetry_sdk::trace::TracerProvider;
use opentelemetry::trace::TracerProvider as _;

let provider = TracerProvider::builder()
    .with_simple_exporter(opentelemetry_stdout::SpanExporter::default())
    .build();
let tracer = provider.tracer(&quot;randy&quot;);

let telemetry_layer  = tracing_opentelemetry::layer().with_tracer(tracer);

tracing_subscriber::registry()
    .with(tracing_subscriber::EnvFilter::from_default_env())
    //.with(fmt_layer)
    .with(telemetry_layer)
    .init();
</code></pre><p>This outputs OpenTelemetry data structures to the console, but the output is very dense and <code>fmt</code> is definitely preferable if you want human readable console logging.</p><h2 id=exporting-to-jaeger-with-otlp>Exporting to Jaeger with OTLP</h2><p>To use OTLP, we just replace the <code>stdout</code> tracer with one from <code>opentelemetry-otlp</code>:</p><pre><code class=language-rust>...
let tracer = opentelemetry_otlp::new_pipeline()
    .tracing()
    .with_exporter(opentelemetry_otlp::new_exporter().tonic())
    .install_batch(opentelemetry_sdk::runtime::Tokio)
    .expect(&quot;Couldn't create OTLP tracer&quot;);

let telemetry_layer = tracing_opentelemetry::layer().with_tracer(tracer);

tracing_subscriber::registry()
    .with(tracing_subscriber::EnvFilter::from_default_env())
    .with(fmt_layer)
    .with(telemetry_layer)
    .init();
</code></pre><p>We&rsquo;ve added <code>fmt_layer</code> back in here, so that we get console logging to compare with what we see in Jaeger. We&rsquo;re also using a batch exporter which exports data periodically and is recommended for performance. Apart from that everything is the same.</p><p>Now pull the docker image for Jaeger:</p><pre><code>$ docker pull jaegertracing/all-in-one:latest
</code></pre><p>And run the Jaeger server:</p><pre><code>$ docker run -d --name jaeger -e COLLECTOR_OTLP_ENABLED=true -p 16686:16686 -p 4317:4317 -p 4318:4318 jaegertracing/all-in-one:latest
</code></pre><p>You can then view the UI by browsing to <code>http://localhost:16686</code>. Ports 4317 and 4318 are used for OTLP over gRPC and HTTP respectively. The <code>tonic</code> exporter we&rsquo;ve configured means we are using gRPC here.</p><p>We can use the environment variable <code>OTEL_SERVICE_NAME</code> to avoid hard-coding a name for our service:</p><pre><code class=language-shell>OTEL_SERVICE_NAME=randy RUST_LOG=&quot;debug,h2=warn&quot; cargo run
</code></pre><p>You will be able to find your requests in the UI. Note that unlike the <code>fmt</code> subscriber, our spans will appear as Jaeger traces even if we don&rsquo;t have debug logging enabled. Spans and events which occur during a request are shown as children of their parent span. For example, the request handler function <code>get_random</code> has the excellent <a href=https://docs.rs/tracing/0.1.37/tracing/attr.instrument.html><code>#[instrument]</code></a> macro applied, which does most of the work for us and causes it to appear as a child span.</p><p><img src=jaeger-ui-rand.webp alt="/rand request trace in Jaeger"></p><p>There will probably be some other traces for <code>GET default</code> requests. This may be confusing, since we don&rsquo;t see anything about these in our console logging but they appear in the OpenTelemetry output. These are our browser&rsquo;s requests for <code>favicon.ico</code> which are returning a 404.</p><h2 id=exporting-to-an-online-provider>Exporting to an online provider</h2><p>In the previous example, the exporter uses a default endpoint which happens to be where our Jaeger server is listening (<code>http://127.0.0.1:4317</code>). The OpenTelemetry SDK in theory allows us to override the endpoint and other settings by using <a href=https://opentelemetry.io/docs/concepts/sdk-configuration/otlp-exporter-configuration/>predefined environment variables</a>.</p><p>Can we use the same code and configure it for any provider by just setting these variables?</p><h3 id=honeycomb>Honeycomb</h3><p>I signed up for a vendor with a free (non-expiring) plan, Honeycomb. <a href=https://docs.honeycomb.io/getting-data-in/opentelemetry-overview/#using-the-honeycomb-opentelemetry-endpoint>Their documentation</a> recommends the same OpenTelemetry crates we are already using and says we should set the variables:</p><pre><code>OTEL_EXPORTER_OTLP_ENDPOINT=api.honeycomb.io:443
OTEL_EXPORTER_OTLP_HEADERS=&quot;x-honeycomb-team=your-api-key&quot;
</code></pre><p>This endpoint will cause an &ldquo;invalid URI&rdquo; error unless we prefix it with &ldquo;https://&rdquo; so that&rsquo;s the first thing we need to change. Also, the variable <code>OTEL_EXPORTER_OTLP_HEADERS</code> isn&rsquo;t recognised by Rust opentelemetry, so we have to parse that ourselves for now <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>. We also need to tell tonic that we want to use TLS <sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>. The code for the exporter would look something like this (note that <code>parse_metadata_from_env</code> doesn&rsquo;t actually exist in the code):</p><pre><code class=language-rust>let exporter = opentelemetry_otlp::new_exporter()
    .tonic()
    .with_metadata(parse_metadata_from_env())
    .with_tls_config(Default::default());
</code></pre><p>For maximum flexibility we might also want to be able to use the <code>http/protobuf</code> protocol rather than being restricted to gRPC. So the final version of the example code reads the value of the <a href=https://opentelemetry.io/docs/reference/specification/protocol/exporter/#specify-protocol><code>OTEL_EXPORTER_OTLP_PROTOCOL</code></a> environment variable to decide what to use (it defaults to &ldquo;grpc&rdquo; if it&rsquo;s not set).
It also checks <code>OTEL_EXPORTER_OTLP_ENDPOINT</code> to see whether it starts with <code>https</code>, before deciding whether to enable TLS for the grpc/tonic exporter. That way we can still use it locally with Jaeger, for example <sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>.</p><p>If we run the app with:</p><pre><code>OTEL_EXPORTER_OTLP_ENDPOINT=https://api.honeycomb.io:443 OTEL_EXPORTER_OTLP_HEADERS=&quot;x-honeycomb-team=your-api-key&quot; OTEL_EXPORTER_OTLP_PROTOCOL=grpc OTEL_SERVICE_NAME=randy RUST_LOG=&quot;debug,h2=warn&quot; cargo run
</code></pre><p>we can finally see our request traces in Honeycomb&rsquo;s dashboard and view individual spans:</p><p><img src=honeycomb-rand.webp alt="/rand request trace in Honeycomb"></p><p>It works!</p><h3 id=aspecto>Aspecto</h3><p>Just to check, I signed up for another free provider, Aspecto, and changed the endpoint and headers:</p><pre><code>OTEL_EXPORTER_OTLP_ENDPOINT=https://otelcol.aspecto.io:4317 OTEL_EXPORTER_OTLP_HEADERS=&quot;Authorization=your-api-key&quot; OTEL_SERVICE_NAME=randy RUST_LOG=&quot;debug,h2=warn&quot; cargo run
</code></pre><p>This worked immediately! <sup id=fnref:10><a href=#fn:10 class=footnote-ref role=doc-noteref>10</a></sup>:</p><p><img src=aspecto-rand.webp alt="/rand request trace in Aspecto"></p><h2 id=conclusion>Conclusion</h2><p>There&rsquo;s a lot more to tracing and telemetry than what we&rsquo;ve covered here, but we&rsquo;ve successfully created a setup that should work with different OpenTelemetry providers, without the need to recompile our app. We can easily configure it using standard environment variables (which will hopefully be supported directly by the opentelemetry libraries some day). This gives us local event logging along with exporting of tracing spans to an OpenTelemetry traces endpoint.</p><p>One issue I had along the way is that it&rsquo;s not obvious what&rsquo;s going on between the opentelemetry client and the endpoint (who traces the tracers 🙂?). When using <code>http/proto</code> I only worked out that I was missing the <code>/v1/traces</code> part of the endpoint URI when I swapped the default <code>reqwest</code> client with one which dumped the request and response to the console. Then I realised the endpoint was returing a <code>404</code> which was being ignored. I haven&rsquo;t worked out if this is possible with gRPC and the <code>tonic</code> version, since I didn&rsquo;t have any similar issues (Update: the issue with HTTP errors being silently ignored should now be fixed <sup id=fnref:11><a href=#fn:11 class=footnote-ref role=doc-noteref>11</a></sup>).</p><p>Overall though I&rsquo;m very pleased with the results and the ecosystem is a pleasure to use, thanks to the many people who have worked hard on the various projects involved to get things to where they are today. Instrumenting your code with Rust tracing is a breeze (particularly using the excellent <code>instrument</code> macro) and exporting to OpenTelemetry seems to be the way to go if you want to export your data to the cloud. Both the providers used above are easy to sign up for with no commitment, and their free plans should be adequate for a small app.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The example app code is a web application using actix, so the root spans we export are created by the <code>tracing-actix-web</code> middleware.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>The SDK crate was not required in earlier versions of this article, since the functionality was directly available via the <code>opentelemetry</code> crate itself.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>It defines the <code>tracing-log</code> crate as an <a href=https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies>optional dependency</a> but it is enabled by default. This confused me a bit to start with because I found references to this feature flag and didn&rsquo;t know that optional dependencies implicitly define features for a crate in Rust.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>The <code>tracing_subscriber::prelude::*</code> import adds in extension traits which provide the <code>with</code> and <code>init</code> <code>Subscriber</code> methods used here. We&rsquo;ll assume this is used in further code snippets.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>For example, you might set <code>RUST_LOG='debug,h2=warn</code> which will output debug level events but suppress anything below warn level from the <code>h2</code> crate which generates a lot of low-level messages which might drown out those from your application.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>You can change this behaviour by calling the <a href=https://docs.rs/tracing-subscriber/latest/tracing_subscriber/fmt/struct.Layer.html#method.with_span_events>with_span_events</a> method when creating the subscriber.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>A fix for this <a href=https://github.com/open-telemetry/opentelemetry-rust/pull/1377>has been merged</a> and is listed in the changelog for <code>opentelemetry-otlp</code> version <code>0.14.0</code>. However this seems to be a mistake as the change is still not in the tonic exporter in this version.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>The <code>tls</code> and <code>tls-roots</code> features need to be enabled on the tonic crate in order to create a connection and validate the server certificate. There are also corresponding features on <code>opentelemetry-otlp</code> which have the same effect.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>Note that you might run into <a href=https://github.com/open-telemetry/opentelemetry-rust/issues/997>this issue</a> when using the HTTP exporter. In the meantime you have to append <code>/v1/traces</code> to the URL for both Jaeger and Honeycomb.&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:10><p>This is a lie, I used the wrong port number to start with 🙂.&#160;<a href=#fnref:10 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:11><p>The <code>0.19</code> release of <code>opentelemetry-otlp</code> now <a href=https://github.com/open-telemetry/opentelemetry-rust/pull/945>reports HTTP errors</a>.&#160;<a href=#fnref:11 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main></div><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "df78f068bb4f4ea0b8a0af4d60345dfd"}'></script></body></html>