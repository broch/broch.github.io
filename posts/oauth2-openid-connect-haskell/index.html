<!doctype html><html lang=en><head><title>OAuth2 and OpenID Connect in Haskell</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Implementing an OpenID Connect provider in Haskell."><link href="/css/main.min.cbea4dffd5bf7bf2c87de9504c4cac811c1f22ad854c538f0e08bbad25d60973.css" rel=stylesheet><link rel=icon type=image/svg+xml href=/images/logo.svg><link rel=stylesheet href=https://rsms.me/inter/inter.css><script src=/js/prism.js></script></head><body class="bg-stone-50 text-stone-600 dark:bg-stone-900 dark:text-stone-400"><nav class="mb-1 shadow dark:shadow-none dark:border-b dark:border-stone-300/10"><div class="max-w-7xl mx-auto px-2 sm:px-6 lg:px-8"><div class="relative flex justify-between h-20"><div class="absolute inset-y-0 left-0 flex items-center sm:hidden"><button id=menu-button type=button class="inline-flex items-center justify-center p-2 rounded-md text-stone-400 hover:text-stone-500 hover:bg-stone-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-red-600" aria-controls=mobile-menu aria-expanded=false>
<span class=sr-only>Open main menu</span><svg id="open-menu-icon" class="block h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/></svg><svg id="close-menu-icon" class="hidden h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18 18 6M6 6l12 12"/></svg></button></div><div class="flex-1 flex items-center justify-center sm:items-stretch sm:justify-start"><div class="flex-shrink-0 flex items-center"><a href=/><svg class="block lg:hidden h-14 w-auto dark:fill-stone-300 dark:stroke-stone-400" viewBox="0 0 1250 1250"><desc>Broch logo</desc><path d="M50 550A5e2 5e2.0 01550 50h145a5e2 5e2.0 015e2 5e2v1e2a5e2 5e2.0 01-5e2 5e2v-130a370 370 0 00370-370m0-1e2A370 370 0 00695 180H550A370 370 0 00180 550m0 1e2a370 370 0 00370 370v130A5e2 5e2.0 0150 650V550" stroke-width="55" fill="none"/></svg><svg class="hidden lg:block h-14 w-auto dark:fill-stone-300 dark:stroke-stone-400" stroke="#292524" fill="#292524" viewBox="0 0 3500 1250"><desc>Broch logo</desc><g><path d="M50 550A5e2 5e2.0 01550 50h145a5e2 5e2.0 015e2 5e2v1e2a5e2 5e2.0 01-5e2 5e2v-130a370 370 0 00370-370m0-1e2A370 370 0 00695 180H550A370 370 0 00180 550m0 1e2a370 370 0 00370 370v130A5e2 5e2.0 0150 650V550" stroke-width="55" fill="none"/></g><g transform="translate(1600 1050) scale(.18 -.18)"><path d="m525 3939c-137-15-256-28-263-28-10-1-12-289-10-1423l3-1423 267-3 267-2 5 32c3 18 10 60 16 92 5 33 10 62 10 64 0 3 33-26 73-64 85-82 137-114 243-151 71-24 93-27 214-27 98-1 153 4 2e2 17 258 69 463 295 555 613 40 137 55 260 55 456 0 417-89 7e2-279 888-128 127-269 181-471 182-201 0-342-54-472-183l-78-76v533 534l-42-1c-24-1-155-14-293-30zm811-1247c56-29 119-103 144-169 34-92 51-230 51-427 0-99-5-213-11-251-31-198-95-316-204-373-44-22-63-26-136-26-122 0-203 40-281 137l-39 50v427 428l43 59c63 84 130 136 217 164 46 15 171 4 216-19z"/><path d="m8303 3942-253-25V2493 1070h3e2 3e2v698 697l51 67c96 128 197 192 303 192 70-1 115-20 144-61 47-69 46-54 50-845l3-748h299 3e2v803c0 891 0 881-66 1016-108 219-359 323-642 265-141-29-251-87-366-195l-76-71v541 541l-47-1c-27-1-162-13-3e2-27z"/><path d="m4655 3155c-268-42-482-178-629-399-234-353-231-1006 7-1356 123-181 310-311 521-360 182-44 421-44 591 0 1e2 25 241 93 322 154 302 228 436 668 356 1166-60 379-286 657-618 759-155 48-380 63-550 36zm306-445c82-23 161-105 2e2-209 65-175 77-537 23-744-35-138-99-228-192-274-50-24-68-28-147-28-105 0-163 23-226 88-99 102-148 320-136 612 7 171 27 277 72 372 78 167 225 234 406 183z"/><path d="m6898 3155c-402-68-686-357-779-795-29-136-32-406-6-547 87-473 408-765 884-803 134-10 285 3 399 35 156 44 393 176 380 211-4 10-223 326-250 361-1 1-51-22-111-52-79-39-135-59-198-71-81-16-93-16-169-1-236 46-330 240-315 642 9 231 49 363 140 462 136 147 391 144 613-7l40-28 128 175c72 1e2 125 182 122 190-9 23-187 132-269 164-195 75-410 97-609 64z"/><path d="m3498 3137c-153-53-279-181-354-364-13-32-24-53-24-48-1 6-11 91-23 190l-22 180-267 3-268 2V2085 1070h305 304l3 533 3 532 33 95c98 283 233 378 480 337 60-10 85-11 88-3 7 20 94 569 91 573-10 10-121 23-196 23-63 0-104-7-153-23z"/></g></svg></a></div><div class="hidden sm:ml-9 sm:flex sm:space-x-8"><a class="border-transparent text-stone-400 hover:border-stone-300 hover:text-stone-700 dark:hover:text-stone-400 inline-flex items-center px-1 pt-1 border-b-2 text-lg font-medium" href=/ title>Home</a>
<a class="border-red-600 dark:border-red-500 text-stone-900 dark:text-stone-300 inline-flex items-center px-1 pt-1 border-b-2 text-lg font-medium" href=/posts/ title=Blog>Blog</a></div></div><div class="absolute inset-y-0 right-0 flex items-center pr-2 sm:static sm:inset-auto sm:ml-6 sm:pr-0"><a href=/index.xml class="p-1 rounded-full text-stone-400 hover:text-stone-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"><span class=sr-only>RSS Feed</span><svg class="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentcolor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 5c7.18.0 13 5.82 13 13M6 11a7 7 0 017 7m-6 0a1 1 0 11-2 0 1 1 0 012 0z"/></svg></a></div></div></div><div class=hidden id=mobile-menu><div class="pt-2 pb-4 space-y-1"><a class="border-transparent text-stone-500 dark:text-stone-300 hover:bg-stone-50 dark:hover:bg-stone-400 hover:border-stone-300 hover:text-stone-700 block pl-3 pr-4 py-2 border-l-4 text-base font-medium" href=/ title>Home</a>
<a class="bg-red-50 dark:bg-red-800 border-red-600 text-red-900 dark:text-red-300 block pl-3 pr-4 py-2 border-l-4 text-base font-medium" href=/posts/ title=Blog>Blog</a></div></div></nav><script>var menu_open=!1,menu_button=document.getElementById("menu-button"),menu=document.getElementById("mobile-menu"),open_icon=document.getElementById("open-menu-icon"),close_icon=document.getElementById("close-menu-icon");menu_button.addEventListener("click",function(){menu_open=!menu_open,menu_open?(menu.className="block sm:hidden",close_icon.className.baseVal="block h-6 w-6",open_icon.className.baseVal="hidden h-6 w-6"):(menu.className="hidden",open_icon.className.baseVal="block h-6 w-6",close_icon.className.baseVal="hidden h-6 w-6")})</script><div class="w-full max-w-7xl mx-auto"><main><article class="py-12 px-4 sm:px-8 lg:px-8 prose prose-stone prose-lg max-w-none lg:prose-xl dark:prose-invert"><h1>OAuth2 and OpenID Connect in Haskell</h1><p class="block flex display-between text-stone-500 dark:text-stone-400 italic">May 2, 2016</p><p>I&rsquo;ve been working for a while on an implementation of the OpenID Connect specification. Since it was something I already knew quite a bit about from my previous job, it seemed like a good idea for a &ldquo;real-world&rdquo; Haskell project. The result is a project called &ldquo;Broch&rdquo; <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, which is an OpenID Connect identity provider. Features include</p><ul><li>OAuth2 flows<ul><li>Authorization endpoint</li><li>Token endpoint</li></ul></li><li>OpenID Connect basic flows</li><li>OpenID Connect hybrid flows</li><li>OpenID Connect Discovery</li><li>Support for signed and encrypted JWTs <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></li><li><a href=http://openid.net/specs/openid-connect-registration-1_0.html>Client Registration</a></li><li>Client authentication<ul><li>Basic authentication with client secret</li><li><a href=https://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-12>JWT Bearer authentication</a></li></ul></li><li>ID Tokens (signed and/or encrypted)</li><li><a href=http://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes>Pairwise subject identifiers</a></li><li>Server key management and rotation <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li><li>SQLite back end</li><li>PostgreSQL 9.5 back end</li></ul><p>You can easily get a prototype server up and running with default settings and it&rsquo;s intended that the important features should be easily customized. This article is mostly an introduction to the project and the Haskell implementation. If you don&rsquo;t know much about OAuth2 or OpenID Connect but are still interested, you should probably check out the <a href=http://openid.net/connect/faq/>OpenID Connect FAQ</a> first to get an overview.</p><h2 id=the-command-line-executable>The Command Line Executable</h2><p>In addition to the main library, the project build creates a <code>broch</code> executable which can be used to get up and running quickly. Instructions for building and running against a SQLite or PostgreSQL database can be found in the project <a href=https://github.com/tekul/broch/blob/master/README.md>readme file</a>. The <a href=https://github.com/tekul/broch/blob/master/broch-server/broch.hs>source code</a> is also a useful reference for building your own server application from scratch.</p><h2 id=coding-a-minimal-server>Coding a Minimal Server</h2><p>In many cases, you will want to write a customized server of your own. To do this, you create a configuration instance (<code>Broch.Server.Config</code>) and pass it to the <code>brochServer</code> function. The only things you <em>have</em> to supply are</p><ul><li>An &ldquo;issuer&rdquo; for the OpenID Provider. This is the external URL used to access your server, for example <code>https://myopenidserver.com</code>.</li><li>A <code>Broch.Server.Config.KeyRing</code> instance to provide the signing and encryption keys for the server. The <code>defaultKeyRing</code> function can be used for this.</li><li>A function to render an &ldquo;approval&rdquo; page, which allows the user to consent to the authorization request.</li><li>A function to authenticate (or reauthenticate) a user.</li><li>A function to provide the identity of the currently authenticated user.</li><li>A means of supplying user information for OpenID authentication requests.</li></ul><p>Some standard options for authentication and user management are provided &ndash; you just need to select them in your configuration. Everything else in a simple test server can use default settings, in-memory storage and provided login handlers.</p><p>The configured server uses WAI and can be run using the warp web server:</p><pre><code class=language-haskell>{-# LANGUAGE OverloadedStrings #-}

import Data.Default.Generics (def)
import qualified Data.Text as T
import Network.Wai.Middleware.RequestLogger (logStdoutDev)
import Network.Wai.Handler.Warp
import Web.Routing.TextRouting

import Broch.Model (Client(..), GrantType(..), Scope(..), UserInfo(..))
import Broch.Server.Config
import Broch.Server (brochServer, authenticatedSubject, authenticateSubject, defaultLoginPage, defaultApprovalPage, passwordLoginHandler)
import Broch.Server.Internal (routerToApp, text, invalidateSession)
import Broch.Server.Session (defaultKey, defaultLoadSession)
import Broch.URI (parseURI)

main :: IO ()
main = do
    sessionEncryptionKey &lt;- defaultKey
    opKeys &lt;- defaultKeyRing
    inMemory &lt;- inMemoryConfig &quot;http://localhost:3000&quot; opKeys Nothing
    let config = inMemory { authenticateResourceOwner = authenticate, getUserInfo = loadUserInfo }
    createClient config testClient
    let extraRoutes =
          [ (&quot;/home&quot;,   text &quot;Hello, I'm the home page&quot;)
          , (&quot;/login&quot;,  passwordLoginHandler defaultLoginPage authenticate)
          , (&quot;/logout&quot;, invalidateSession &gt;&gt; text &quot;You have been logged out&quot;)
          ]
        routingTable = foldl (\tree (r, h) -&gt; addToRoutingTree r h tree) (brochServer config defaultApprovalPage authenticatedSubject authenticateSubject) extraRoutes
        waiApp = routerToApp (defaultLoadSession 3600 sessionEncryptionKey) (issuerUrl config) routingTable
    run 3000 $ logStdoutDev waiApp
  where
    Right uri = parseURI &quot;http://c123.client&quot;
    testClient = def
      { clientId = &quot;123&quot;
      , clientSecret = Just &quot;abc123&quot;
      , authorizedGrantTypes = [AuthorizationCode]
      , redirectURIs = [uri]
      , allowedScope = [OpenID]
      }
    authenticate username password
      | username == password = return (Just username)
      | otherwise            = return Nothing

    loadUserInfo uid _ = return . Just $ def
      { sub = uid
      , email = Just (T.concat [uid, &quot;@someplace.com&quot;])
      }
</code></pre><p>The web code is similar to that in <a href=http://broch.tech/posts/build-your-own-wai-framework/>an earlier article on WAI</a>, but includes the concept of a session, since users have to be able to authenticate to the authorization server. The <code>brochServer</code> function converts the configuration into a routing table, mapping URL paths to web handler functions and we add extra handlers for login/logout processing also to render a very basic home page. The <a href=hackage.haskell.org/package/reroute>reroute</a> package is used to build the routing table. The table is then converted into a WAI <code>Application</code> which we can run.</p><p>We&rsquo;ve added a single client which is allowed to use the authorization code flow and will use basic authentication (the default) at the token endpoint.</p><p>Neither OAuth2 nor OpenID Connect define how authentication of the end user should take place at the authorization server, so user account data and authentication are decoupled from the core OpenID/OAuth2 functionality. Here we have used an authentication function which merely compares the username and password for equality, so there aren&rsquo;t actually any user accounts &ndash; you can authenticate with any name. For &ldquo;user info&rdquo; requests, we&rsquo;ve just added a function <code>loadUserInfo</code> to make up the data. In a real implementation, you would have a specific user data type and would write functions to manage user accounts and convert the data to the claims returned for a user info request <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. A side project is an implementation based on the SCIM specification <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</p><h3 id=database-backend>Database Backend</h3><p>To add persistent storage, there are SQLite and PostgreSQL backs end available, which are built on top of the <code>sqlite-simple</code> and <code>postresql-simple</code> packages. These are used in the <a href=https://github.com/tekul/broch/blob/master/broch-server/broch.hs>command-line source</a> which you can examine along with the project readme for more details. We could swap from in-memory to using Postgres just by changing the configuration to</p><pre><code class=language-haskell>config &lt;- postgreSQLBackend pool &lt;$&gt; inMemoryConfig issuer opKeys Nothing
</code></pre><p>where <code>pool</code> is a <code>Data.Pool</code> of Postgres <code>Connection</code> instances. The project has some SQL scripts for setting up the Postgres database schema. It requires Postgres 9.5 or later. The SQLite backend creates the schema as required.</p><h2 id=authorization-code-flow-walk-through>Authorization Code Flow Walk-Through</h2><p>Using the server above, we can work through a typical flow which a client application would use to authenticate a user. We&rsquo;ll use <code>curl</code> to take the place of the client. All URLs would use HTTPS in a production system.</p><p>The first step is a redirection from the client to the authorization server, which creates the <a href="http://localhost:3000/oauth/authorize?client_id=123&amp;state=982147&amp;response_type=code&amp;redirect_uri=http%3A%2F%2Fc123.client">following request</a> <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>:</p><pre><code class=language-plain>http://localhost:3000/oauth/authorize?client_id=123&amp;state=982147&amp;response_type=code&amp;scope=openid&amp;redirect_uri=http%3A%2F%2Fc123.client
</code></pre><p>The user will be asked to log in (if they aren&rsquo;t already authenticated to the authorization server), and then to approve the request for <code>openid</code> scope. Once this is granted, the authorization server redirects back to the client application, with an authorization code:</p><pre><code class=language-plain>http://c123.client/?state=982147&amp;code=14581d956c81535c&amp;scope=openid
</code></pre><p>The client then exchanges the code at the token endpoint for an <code>access_token</code> and an <code>id_token</code>, which are returned in a JSON response:</p><pre><code class=language-shell-session>$ curl -u 123:abc123 -H &quot;Accept: application/json&quot; -X POST -d code=14581d956c81535c -d client_id=123 -d redirect_uri=http://c123.client -d grant_type=authorization_code http://localhost:3000/oauth/token
{&quot;expires_in&quot;:3600,&quot;access_token&quot;:&quot;eyJhbGciOiJSU0EtT0FFUCIsImtpZCI6IjIwMTUtMDUtMTlUMjA6MjI6MjUuMTc2MjY1MDAwMDAwWiIsImVuYyI6IkExMjhHQ00ifQ.bESkEA-0vGBhnftPuRLYcxvZuD6xbdTrp4h34zBxsn0AhNgXxAOsMsvC-14YijuMBAU4SxkMsBoxL4P4vEWODGrVwK8xb0_OogyxsrCSRYiYwYopU3xli9k3Dw_LpP0vFC60r1oGGsGexeKsAYy9BwL5kGeTNt9GtnjI2Q-WnrA.oZvgWxUtv4-RNddd.xcaT8kydCGN4Oe_JH5QvFTxsE9YJMJ976b1PEAkHvjHj2xcEM1pE_3MCsEGOV7tSho6omNCJFZC_AiKfP2s4QBLvXxG9kMON7OIIjrx4FKDuTAoZgtl-4aiQ_mt-ppt2lVf0pr03cYTvoBzJK85ofMnNeLsnrjA3oGB-xGxXSG5ZKkyutNo.X4ncv5rOTTBOE6hdclpWYg&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;id_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsImtpZCI6IjIwMTUtMDUtMTlUMjA6MjI6MjQuMTc2MjY1MDAwMDAwWiJ9.eyJzdWIiOiJjYXQiLCJleHAiOjE0MzIxMzkxMDgsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCIsImlhdCI6MTQzMjEzODEwOCwiYXV0aF90aW1lIjoxNDMyMTM3MTY5LCJhdWQiOlsiMTIzIl19.f_EJI-wiDT1oa0Cta12yco73BurkYTCR-yrxl3k5zsYO7wNrHc9y2QE-ahmkdsiHdlzCZ4roF7_fVXRMHL2JNsC3S6oyeWfO6E-8sjsTFBRvkDSOCbYwm7HnYW-VWZ1e2M8g_RgZb4SVzW4OK55QntRvlwW6Aj6Tu_AN6Dg7Ua4&quot;}
</code></pre><p>The <code>id_token</code> is defined by the spec to be a JWT. In this implementation, access tokens are also JWTs by default.</p><p>The client can then use the access token to request more information about the user:</p><pre><code class=language-shell-session>$ TOKEN=eyJhbGciOiJSU0EtT0FFUCIsImtpZCI6IjIwMTUtMDUtMTlUMjA6MjI6MjUuMTc2MjY1MDAwMDAwWiIsImVuYyI6IkExMjhHQ00ifQ.bESkEA-0vGBhnftPuRLYcxvZuD6xbdTrp4h34zBxsn0AhNgXxAOsMsvC-14YijuMBAU4SxkMsBoxL4P4vEWODGrVwK8xb0_OogyxsrCSRYiYwYopU3xli9k3Dw_LpP0vFC60r1oGGsGexeKsAYy9BwL5kGeTNt9GtnjI2Q-WnrA.oZvgWxUtv4-RNddd.xcaT8kydCGN4Oe_JH5QvFTxsE9YJMJ976b1PEAkHvjHj2xcEM1pE_3MCsEGOV7tSho6omNCJFZC_AiKfP2s4QBLvXxG9kMON7OIIjrx4FKDuTAoZgtl-4aiQ_mt-ppt2lVf0pr03cYTvoBzJK85ofMnNeLsnrjA3oGB-xGxXSG5ZKkyutNo.X4ncv5rOTTBOE6hdclpWYg
$ curl -H &quot;Accept: application/json&quot; -H &quot;Authorization: Bearer $TOKEN&quot; http://localhost:3000/connect/userinfo
{&quot;email&quot;:&quot;cat@someplace.com&quot;,&quot;sub&quot;:&quot;cat&quot;}
</code></pre><h2 id=configuration>Configuration</h2><p>One of the design issues I had trouble with was the how best to build a configurable server application. It&rsquo;s easy enough to come up with intelligent defaults for an OpenID Provider, but pretty much all the functionality needs to be pluggable <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>. The <code>Broch.Server.Config</code> module contains data structures for settings which are used to initialize a server, and also functions which define pluggable behaviour</p><pre><code class=language-haskell>data Config m s = Config
    { issuerUrl                  :: Text
    , keyRing                    :: KeyRing m
    , responseTypesSupported     :: [ResponseType]
    , algorithmsSupported        :: SupportedAlgorithms
    , clientAuthMethodsSupported :: [ClientAuthMethod]
    , claimsSupported            :: [Text]
    , createClient               :: CreateClient m
    , getClient                  :: LoadClient m
    , createAuthorization        :: CreateAuthorization m s
    , getAuthorization           :: LoadAuthorization m
    , authenticateResourceOwner  :: AuthenticateResourceOwner m
    , createApproval             :: CreateApproval m
    , getApproval                :: LoadApproval m
    , createAccessToken          :: CreateAccessToken m
    , decodeAccessToken          :: DecodeAccessToken m
    , decodeRefreshToken         :: DecodeRefreshToken m
    , getUserInfo                :: LoadUserInfo m
    }
</code></pre><p>The functions are type aliases, for example</p><pre><code class=language-haskell>type LoadClient m = ClientId -&gt; m (Maybe Client)
</code></pre><p>The implementations can then be written in any way, as long as they end up satisfying the required type. They can use partial application, for example, to pass other dependencies such as connection pools.</p><h2 id=the-server>The Server</h2><p>The <code>brochServer</code> function used above is in the <a href=https://github.com/tekul/broch/blob/master/Broch/Server.hs><code>Broch.Server</code></a> module, which also contains most of the web handler code. This is where everything is plugged together to create the server and is thus the most useful source for understanding how the implementation works. It also contains the default functions for authentication and the user interface, which we used above.</p><p>Most of the work for processing authorization and token requests is decoupled from the HTTP interface (WAI) and the code is in separate modules. The web handlers extract the request data, bundle the parameters up in a map, then delegate the detailed work to other functions. This makes it easier to test the core functionality and to use it with a different web front-end.</p><h3 id=authorization-endpoint>Authorization Endpoint</h3><p>The result of an authorization request can be one of</p><ul><li>A redirect containing the authorization information (an authorization code, access token or whatever other data is required by the grant request)</li><li>A redirect to enable user authentication, before continuing processing the original authorization request</li><li>An error returned to the user agent, due to a potentially malicious client request</li><li>A redirect error, where the error information is returned to the client in the URL.</li></ul><p>The authorization web handler authenticates the user and then delegates to the function <a href=https://github.com/tekul/broch/blob/master/Broch/OAuth2/Authorize.hs><code>processAuthorizationRequest</code></a>.</p><h3 id=token-endpoint>Token Endpoint</h3><p>The token endpoint authenticates the client and then calls the function <a href=https://github.com/tekul/broch/blob/master/Broch/OAuth2/Token.hs><code>processTokenRequest</code></a>, return a JSON response as defined in the specification. This can be either a token response or an error response.</p><h3 id=dynamic-registration>Dynamic Registration</h3><p>The server can optionally support <a href=http://openid.net/specs/openid-connect-registration-1_0.html>client registration</a>.</p><h3 id=discovery>Discovery</h3><p>The discovery endpoint just provides a well-known location for clients to obtain a copy of the server&rsquo;s configuration and supported features, such as the algorithms which can be used for encoding JWTs and the URLs of the other endpoints. The information is published at the standard URL path <code>/.well-known/openid-configuration</code>.</p><h3 id=userinfo>UserInfo</h3><p>A client can optionally retrieve user details from the &ldquo;user info&rdquo; endpoint by submitting the access token which was issued by the authorization server. This isn&rsquo;t strictly necessary, as OpenID Connect also isssues an ID token which asserts the identity of the authenticated user and this may contain enough information, depending on the client&rsquo;s requirements.</p><h3 id=front-end>Front End</h3><p>The UI requirements are minimal and will usually consist of</p><ul><li>A login page of some kind, unless the authorization server uses some authentication mechanism which doesn&rsquo;t require one.</li><li>A page to obtain the user&rsquo;s approval for the information requested by the client.</li></ul><p>Default implementations are provided for both of these. The login page is used with the <code>passwordLoginHandler</code> and is a plain Blaze <code>Html</code> page. User approval is a function which takes the approval data and returns an <code>Html</code> page. The command-line server will also serve up static content from a configured directory, which can be used to provide CSS and image files for the UI.</p><h3 id=client-authentication>Client Authentication</h3><p>OAuth2 only mentions client authentication using a password/secret, either using a Basic authorization header or passing the credentials in the request body. Providers are also free to accept other forms of authentication.</p><p>OpenID Connect explicitly defines the <a href=http://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication>client authentication methods</a> which it supports. All of these are available in this implementation.</p><h3 id=key-rotation>Key Rotation</h3><p>The server&rsquo;s public keys can be obtained from the <code>jwks_uri</code> endpoint (which is returned in the server discovery data). It contains all the public keys which a client might need to validate server signatures and to encrypt data to send to the server.</p><p>The rotation of <a href=http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys>signing</a> and <a href=http://openid.net/specs/openid-connect-core-1_0.html#RotateEncKeys>encryption</a> keys is also covered in the spec. The <code>KeyRing</code> data type stores two active key pairs &ndash; one for signing and one for encryption. It also has a function to rotate the keys, expiring the previous active keys and generating news ones. Unless the keys need to be invalidated immediately (for security reasons, for example), the expired signing keys will still be available from the <code>jwks_uri</code> endpoint for a configurable grace period, so that tokens created with earlier signing keys will still validate. The server will also retain decryption private keys internally for the grace period.</p><h2 id=developing-in-haskell>Developing in Haskell</h2><p>The project has been a good learning experience and I&rsquo;ve found Haskell to be particularly suitable for working to a complicated specification like OAuth2/OpenID Connect. The different errors and outcomes of a request can be modelled nicely using algebraic data types and using the <code>Either</code> type allows us to deal with all the error conditions defined by the spec while keeping IO errors (for example, data access errors) completely separate. As an example, the return type for <code>processAuthorizationRequest</code> is</p><pre><code class=language-haskell>m (Either AuthorizationRequestError URI)
</code></pre><p>The code runs in an arbitrary monad and thus does not contain any IO code. In practice <code>m</code> will be a <code>MonadIO</code> instance, since the functions for loading clients and so on will need to make calls to a database. Any IO errors should be returned as <code>500</code> responses but in the absence of these, we know from the type that the outcome of a call to the function will be either an <code>AuthorizationRequestError</code> or a URI which we should redirect to <sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>.</p><p><code>AuthorizationRequestError</code> is a data type which captures the cases where the request will &ldquo;short-circuit&rdquo;:</p><ul><li>The client shows potentially malicious behaviour which should be reported to the end user.</li><li>The client has submitted an otherwise invalid request, which should be reported to it via a redirect.</li><li>The user needs to re-authenticate. This typically happens when the client requires that the previous login took place within a certain period.</li></ul><p>The actual data type is:</p><pre><code class=language-haskell>data AuthorizationRequestError
    = MaliciousClient EvilClientError
    | RequiresAuthentication
    | ClientRedirectError URI
</code></pre><p>In deciding how to respond to the request, the handler code needs to pattern-match on the types and we can&rsquo;t, for example, redirect the user to a malicious client by accident. The compiler will also generally warn if we forget to match on one of the options, which forces us to deal with all the cases. In future, the <a href=http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html>OAuth2 Form Post</a> spec will also be implemented, which would again modify the return type, probably changing the successful outcome from a simple redirect to either a redirect or a form post. The compiler would immediately point this out to calling code, making it difficult to call the function without also dealing with this case.</p><p>This was a recurring theme &ndash; data types written to match the specification would in turn drive the development and ensure that all the corner cases had been dealt with.</p><h2 id=future-work>Future Work</h2><p>Broch implements most of the features for an OpenID Connect Provider required by the certification programme <sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>. Work on additional features is ongoing. The current aim is to develop an opinionated but customizable solution for authentication based on OpenID Connect, rather than an identity management solution which does <em>everything</em>. Even so, a production-ready solution requires a lot more than simple spec conformance. Suggestions for future development and also improvements to the current code are welcome.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This follows from the contrived acronym &ldquo;Basic Realization of OpenID Connect in Haskell&rdquo;, but I chose the name first and the acronym later. If someone can think of a better one, please let me know. Brochs are tall, round iron age buildings and I enjoyed playing in the ruins of some of them when I was young. They are of simple design, solidly engineered and secure. All good goals for an identity management system to aspire to, even an implementation of OAuth2/OpenID Connect.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>JWTs are implemented in a separate project <a href=http://hackage.haskell.org/package/jose-jwt><code>jose-jwt</code></a>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Key rotation is described in the <a href=http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys><code>openid-connect-core</code></a> spec.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>OpenID Connect defines a specific set of <a href=http://openid.net/specs/openid-connect-core-1_0.html#Claims>claims</a>, which unfortunately aren&rsquo;t directly compatible with SCIM.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>The aim is to build a full implementation of <a href=http://www.simplecloud.info/>the SCIM 2 spec</a>, but this is a work in progress, and SCIM may be overkill for many use cases.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>See the <a href=http://openid.net/specs/openid-connect-core-1_0.html#CodeFlowSteps>spec</a> for a more in-depth description. The only thing that will usually vary in this request is the <code>state</code> parameter which is generated by the client.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>Functional programmers enjoy making fun of other languages and their inadequacies in this department (just mention &ldquo;dependency injection&rdquo; and watch the reaction), but concrete examples of how to build a Haskell server with a pluggable configuration are thin on the ground. For a beginner it&rsquo;s not clear where to start. If you&rsquo;re using a framework like Yesod, then it uses typeclasses to implement different functionality you might want in your application, and you can override specific functions if you wish. However, I&rsquo;d already decided I didn&rsquo;t want to tie the project to any specific framework and I wasn&rsquo;t overly keen on using typeclasses for everything. The approach I settled on was inspired by this <a href=http://stackoverflow.com/a/14329487/241990>Stack Overflow answer</a>.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p>The spec actually says that 500 errors should be returned as a redirect to the client, but that can be handled by a single catch in the handler code.&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p>A deployed server has been tested successfully against the certification suite. Some optional features aren&rsquo;t implemented yet. More information on certification can be found on the <a href=http://openid.net/certification/>OpenID site</a>.&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main></div><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "df78f068bb4f4ea0b8a0af4d60345dfd"}'></script></body></html>